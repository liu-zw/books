
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>email.policy: Policy 对象 &#8212; Python 3.9.1 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.9.1 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="email.errors: 异常和缺陷类" href="email.errors.html" />
    <link rel="prev" title="email.generator: 生成 MIME 文档" href="email.generator.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/email.policy.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 异常和缺陷类"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="email.generator: 生成 MIME 文档"
             accesskey="P">上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.9.1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >互联网数据处理</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-email.policy">
<span id="email-policy-policy-objects"></span><h1><a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.policy</span></code></a>: Policy 对象<a class="headerlink" href="#module-email.policy" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<p><strong>源代码:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/email/policy.py">Lib/email/policy.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 的主要焦点是按照各种电子邮件和 MIME RFC 的描述来处理电子邮件消息。 但是电子邮件消息的基本格式（一个由名称加冒号加值的标头字段构成的区块，后面再加一个空白行和任意的‘消息体’）是在电子邮件领域以外也获得应用的格式。 这些应用的规则有些与主要电子邮件 RFC 十分接近，有些则很不相同。 即使是操作电子邮件，有时也可能需要打破严格的 RFC 规则，例如生成可与某些并不遵循标准的电子邮件服务器互联的电子邮件，或者是实现希望应用某些破坏标准的操作方式的扩展。</p>
<p>Policy 对象给予 email 包处理这些不同用例的灵活性。</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 对象封装了一组属性和方法用来在使用期间控制 email 包中各个组件的行为。 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例可以被传给 email 包中的多个类和方法以更改它们的默认行为。 可设置的值及其默认值如下所述。</p>
<p>在 email 包中的所有类会使用一个默认的策略。 对于所有 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 类及相关的便捷函数，还有对于 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 类来说，它是 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a> 策略，通过其对应的预定义实例 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a> 来使用。 这个策略提供了与 Python3.3 版之前的 email 包的完全向下兼容性（在某些情况下，也包括对缺陷的兼容性）。</p>
<p>传给 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 的 <em>policy</em> 关键字的默认值是 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 策略，表示为其预定义的实例 <a class="reference internal" href="#email.policy.default" title="email.policy.default"><code class="xref py py-data docutils literal notranslate"><span class="pre">default</span></code></a>。</p>
<p>在创建 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 或 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 对象时，它需要一个策略。 如果消息是由 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 创建的，则传给该解析器的策略将是它所创建的消息所使用的策略。 如果消息是由程序创建的，则该策略可以在创建它的时候指定。 当消息被传递给 <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">generator</span></code></a> 时，生成器默认会使用来自该消息的策略，但你也可以将指定的策略传递给生成器，这将覆盖存储在消息对象上的策略。</p>
<p><a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> 类和解析器便捷函数的 <em>policy</em> 关键字的默认值在未来的 Python 版本中 <strong>将会改变</strong>。 因此在调用任何 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 模块所描述的类和函数时你应当 <strong>总是显式地指定你想要使用的策略</strong>。</p>
<p>本文档的第一部分介绍了 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 的特性，它是一个 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>，定义了所有策略对象包括 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a> 的共有特性。 这些特性包括一些由 email 包内部调用的特定钩子方法，自定义策略可以重载这些方法以获得不同行为。 第二部分描述了实体类 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 和 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>，它们分别实现了提供标准行为和向下兼容行为与特性的钩子。</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例是不可变的，但它们可以被克隆，接受与类构造器一致的关键字参数并返回一个新的 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例，新实例是原实例的副本，但具有被改变的指定属性。</p>
<p>例如，以下代码可以被用来从一个 Unix 系统的磁盘文件中读取电子邮件消息并将其传递给系统的 <code class="docutils literal notranslate"><span class="pre">sendmail</span></code> 程序:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="kn">import</span> <span class="n">message_from_binary_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">BytesGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="kn">import</span> <span class="n">policy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mymsg.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">msg</span> <span class="o">=</span> <span class="n">message_from_binary_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;sendmail&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;To&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>这里我们让 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> 在创建要送入 <code class="docutils literal notranslate"><span class="pre">sendmail's</span></code> <code class="docutils literal notranslate"><span class="pre">stdin</span></code> 的二进制字串时使用符合 RFC 的行分隔字符，默认的策略将会使用 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 行分隔符。</p>
<p>某些 email 包的方法接受一个 <em>policy</em> 关键字参数，允许为该方法重载策略。 例如，以下代码使用了来自之前示例的 <em>msg</em> 对象的 <a class="reference internal" href="email.compat32-message.html#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 方法并使用其运行所在平台的本机行分隔符将消息写入一个文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;converted.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">as_bytes</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)))</span>
<span class="go">17</span>
</pre></div>
</div>
<p>Policy 对象也可使用加法运算符进行组合来产生一个新策略对象，其设置是被加总对象的非默认值的组合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compat_SMTP</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">raise_on_defect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict_SMTP</span> <span class="o">=</span> <span class="n">compat_SMTP</span> <span class="o">+</span> <span class="n">compat_strict</span>
</pre></div>
</div>
<p>此运算不满足交换律；也就是说对象的添加顺序很重要。 见以下演示:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">policy100</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">policy80</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy100</span> <span class="o">+</span> <span class="n">policy80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy80</span> <span class="o">+</span> <span class="n">policy100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">100</span>
</pre></div>
</div>
<dl class="class">
<dt id="email.policy.Policy">
<em class="property">class </em><code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">Policy</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy" title="永久链接至目标">¶</a></dt>
<dd><p>这是所有策略类的 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>。 它提供了一些简单方法的默认实现，以及不可变特征属性，<a class="reference internal" href="#email.policy.Policy.clone" title="email.policy.Policy.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> 方法以及构造器语义的实现。</p>
<p>可以向策略类的构造器传入各种关键字参数。 可以指定的参数是该类的任何非方法特征属性，以及实体类的任何额外非方法特征属性。 在构造器中指定的值将覆盖相应属性的默认值。</p>
<p>这个类定义了下列特征属性，因此下列值可以被传给任何策略类的构造器:</p>
<dl class="attribute">
<dt id="email.policy.Policy.max_line_length">
<code class="sig-name descname">max_line_length</code><a class="headerlink" href="#email.policy.Policy.max_line_length" title="永久链接至目标">¶</a></dt>
<dd><p>序列化输出中任何行的最大长度，不计入行字符的末尾。 默认值为 78，基于 <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>。 值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 表示完全没有行包装。</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.linesep">
<code class="sig-name descname">linesep</code><a class="headerlink" href="#email.policy.Policy.linesep" title="永久链接至目标">¶</a></dt>
<dd><p>用来在序列化输出中确定行的字符串。 默认值为 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 因为这是 Python 所使用的内部行结束符规范，但 RFC 的要求是 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>。</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.cte_type">
<code class="sig-name descname">cte_type</code><a class="headerlink" href="#email.policy.Policy.cte_type" title="永久链接至目标">¶</a></dt>
<dd><p>控制可能要求使用的内容传输编码格式类型。 可能的值包括:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">7bit</span></code></p></td>
<td><p>所有数据必须为 &quot;纯 7 比特位&quot; (仅 ASCII)。 这意味着在必要情况下数据将使用可打印引用形式或 base64 编码格式进行编码。</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">8bit</span></code></p></td>
<td><p>数据不会被限制为纯 7 比特位。 标头中的数据仍要求仅 ASCII 因此将被编码（参阅下文的 <a class="reference internal" href="#email.policy.Policy.fold_binary" title="email.policy.Policy.fold_binary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold_binary()</span></code></a> 和 <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> 了解例外情况），但消息体部分可能使用 <code class="docutils literal notranslate"><span class="pre">8bit</span></code> CTE。</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 值为 <code class="docutils literal notranslate"><span class="pre">8bit</span></code> 仅适用于 <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">Generator</span></code>，因为字符串不能包含二进制数据。 如果 <code class="docutils literal notranslate"><span class="pre">Generator</span></code> 运行于指定了 <code class="docutils literal notranslate"><span class="pre">cte_type=8bit</span></code> 的策略，它的行为将与 <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 为 <code class="docutils literal notranslate"><span class="pre">7bit</span></code> 相同。</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.raise_on_defect">
<code class="sig-name descname">raise_on_defect</code><a class="headerlink" href="#email.policy.Policy.raise_on_defect" title="永久链接至目标">¶</a></dt>
<dd><p>如为 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，则遇到的任何缺陷都将引发错误。 如为 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (默认值)，则缺陷将被传递给 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a> 方法。</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.mangle_from_">
<code class="sig-name descname">mangle_from_</code><a class="headerlink" href="#email.policy.Policy.mangle_from_" title="永久链接至目标">¶</a></dt>
<dd><p>如为 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，则消息体中以 <em>&quot;From &quot;</em> 开头的行会通过在其前面放一个 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 来进行转义。 当消息被生成器执行序列化时会使用此形参。 默认值t: <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能: </span><em>mangle_from_</em> 形参。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.message_factory">
<code class="sig-name descname">message_factory</code><a class="headerlink" href="#email.policy.Policy.message_factory" title="永久链接至目标">¶</a></dt>
<dd><p>用来构造新的空消息对象的工厂函数。 在构建消息时由解析器使用。 默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，在此情况下会使用 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
</dd></dl>

<p>下列 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 方法是由使用 email 库的代码来调用以创建具有自室外设置的策略实例:</p>
<dl class="method">
<dt id="email.policy.Policy.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.clone" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个新的 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 实例，其属性与当前实例具有相同的值，除非是那些由关键字参数给出了新值的属性。</p>
</dd></dl>

<p>其余的 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 方法是由 email 包代码来调用的，而不应当被使用 email 包的应用程序所调用。 自定义的策略必须实现所有这些方法。</p>
<dl class="method">
<dt id="email.policy.Policy.handle_defect">
<code class="sig-name descname">handle_defect</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.handle_defect" title="永久链接至目标">¶</a></dt>
<dd><p>处理在 <em>obj</em> 上发现的 <em>defect</em>。 当 email 包调用此方法时，<em>defect</em> 将总是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code> 的一个子类。</p>
<p>默认实现会检查 <a class="reference internal" href="#email.policy.Policy.raise_on_defect" title="email.policy.Policy.raise_on_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">raise_on_defect</span></code></a> 旗标。 如果其为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则 <em>defect</em> 会被作为异常来引发。 如果其为 <code class="docutils literal notranslate"><span class="pre">False</span></code> (默认值)，则 <em>obj</em> 和 <em>defect</em> 会被传递给 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.register_defect">
<code class="sig-name descname">register_defect</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.register_defect" title="永久链接至目标">¶</a></dt>
<dd><p>在 <em>obj</em> 上注册一个 <em>defect</em>。 在 email 包中，<em>defect</em> 将总是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code> 的一个子类。</p>
<p>默认实现会调用 <em>obj</em> 的 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 属性的 <code class="docutils literal notranslate"><span class="pre">append</span></code> 方法。 当 email 包调用 <a class="reference internal" href="#email.policy.Policy.handle_defect" title="email.policy.Policy.handle_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">handle_defect</span></code></a> 时，<em>obj</em> 通常将具有一个带 <code class="docutils literal notranslate"><span class="pre">append</span></code> 方法的 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 属性。 配合 email 包使用的自定义对象类型（例如自定义的 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 对象）也应当提供这样的属性，否则在被解析消息中的缺陷将引发非预期的错误。</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_max_count">
<code class="sig-name descname">header_max_count</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_max_count" title="永久链接至目标">¶</a></dt>
<dd><p>返回名为 <em>name</em> 的标头的最大允许数量。</p>
<p>当添加一个标头到 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 或 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 对象时被调用。 如果返回值不为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">None</span></code>，并且已有的名称为 <em>name</em> 的标头数量大于等于所返回的值，则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">Message.__setitem__</span></code> 的默认行为是将值添加到标头列表，因此很容易不知情地创建重复的标头。 此方法允许在程序中限制可以被添加到 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中的特定标头的实例数量。 （解析器不会考虑此限制，它将忠实地产生被解析消息中存在的任意数量的标头。）</p>
<p>默认实现对于所有标头名称都返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_source_parse">
<code class="sig-name descname">header_source_parse</code><span class="sig-paren">(</span><em class="sig-param">sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_source_parse" title="永久链接至目标">¶</a></dt>
<dd><p>email 包调用此方法时将传入一个字符串列表，其中每个字符串以在被解析源中找到的行分隔符结束。 第一行包括字段标头名称和分隔符。 源中的所有空白符都会被保留。 此方法应当返回 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 元组以保存至 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中来代表被解析的标头。</p>
<p>如果一个实现希望保持与现有 email 包策略的兼容性，则 <em>name</em> 应当为保留大小写形式的名称（所有字符直至 '<code class="docutils literal notranslate"><span class="pre">:</span></code>' 分隔符），而 <em>value</em> 应当为展开后的值（移除所有行分隔符，但空白符保持不变），并移除开头的空白符。</p>
<p><em>sourcelines</em> 可以包含经替代转义的二进制数据。</p>
<p>此方法没有默认实现</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_store_parse">
<code class="sig-name descname">header_store_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_store_parse" title="永久链接至目标">¶</a></dt>
<dd><p>当一个应用通过程序代码修改 <code class="docutils literal notranslate"><span class="pre">Message</span></code> (而不是由解析器创建 <code class="docutils literal notranslate"><span class="pre">Message</span></code>) 时，email 包会调用此方法并附带应用程序所提供的名称和值。 此方法应当返回 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 元组以保存至 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中用来表示标头。</p>
<p>如果一个实现希望保持与现有 email 包策略的兼容性，则 <em>name</em> 和 <em>value</em> 应当为字符串或字符串的子类，它们不会修改在参数中传入的内容。</p>
<p>此方法没有默认实现</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_fetch_parse">
<code class="sig-name descname">header_fetch_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_fetch_parse" title="永久链接至目标">¶</a></dt>
<dd><p>当标头被应用程序所请求时，email 包会调用此方法并附带当前保存在 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中的 <em>name</em> 和 <em>value</em>，并且无论此方法返回什么它都会被回传给应用程序作为被提取标头的值。 请注意可能会有多个相同名称的标头被保存在 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 中；此方法会将指定标头的名称和值返回给应用程序。</p>
<p><em>value</em> 可能包含经替代转义的二进制数据。 此方法所返回的值应当没有经替代转义的二进制数据。</p>
<p>此方法没有默认实现</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold" title="永久链接至目标">¶</a></dt>
<dd><p>The email package calls this method with the <em>name</em> and <em>value</em> currently
stored in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> for a given header.  The method should return a
string that represents that header &quot;folded&quot; correctly (according to the
policy settings) by composing the <em>name</em> with the <em>value</em> and inserting
<a class="reference internal" href="#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linesep</span></code></a> characters at the appropriate places.  See <span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>
for a discussion of the rules for folding email headers.</p>
<p><em>value</em> may contain surrogateescaped binary data.  There should be no
surrogateescaped binary data in the string returned by the method.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold_binary">
<code class="sig-name descname">fold_binary</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold_binary" title="永久链接至目标">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.Policy.fold" title="email.policy.Policy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a>, except that the returned value should be a
bytes object rather than a string.</p>
<p><em>value</em> may contain surrogateescaped binary data.  These could be
converted back into binary data in the returned bytes object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.policy.EmailPolicy">
<em class="property">class </em><code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">EmailPolicy</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy" title="永久链接至目标">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> provides behavior that is intended to be fully
compliant with the current email RFCs.  These include (but are not limited
to) <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>, and the current MIME RFCs.</p>
<p>This policy adds new header parsing and folding algorithms.  Instead of
simple strings, headers are <code class="docutils literal notranslate"><span class="pre">str</span></code> subclasses with attributes that depend
on the type of the field.  The parsing and folding algorithm fully implement
<span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a> and <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>.</p>
<p>The default value for the <a class="reference internal" href="#email.policy.Policy.message_factory" title="email.policy.Policy.message_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message_factory</span></code></a>
attribute is <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>.</p>
<p>In addition to the settable attributes listed above that apply to all
policies, this policy adds the following additional attributes:</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.utf8">
<code class="sig-name descname">utf8</code><a class="headerlink" href="#email.policy.EmailPolicy.utf8" title="永久链接至目标">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, follow <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, supporting non-ASCII characters in
headers by encoding them as &quot;encoded words&quot;.  If <code class="docutils literal notranslate"><span class="pre">True</span></code>, follow
<span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html"><strong>RFC 6532</strong></a> and use <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> encoding for headers.  Messages
formatted in this way may be passed to SMTP servers that support
the <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> extension (<span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.refold_source">
<code class="sig-name descname">refold_source</code><a class="headerlink" href="#email.policy.EmailPolicy.refold_source" title="永久链接至目标">¶</a></dt>
<dd><p>If the value for a header in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> object originated from a
<a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> (as opposed to being set by a program), this
attribute indicates whether or not a generator should refold that value
when transforming the message back into serialized form.  The possible
values are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">none</span></code></p></td>
<td><p>all source values use original folding</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>source values that have any line that is longer than
<code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> will be refolded</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">all</span></code></p></td>
<td><p>all values are refolded.</p></td>
</tr>
</tbody>
</table>
<p>The default is <code class="docutils literal notranslate"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.header_factory">
<code class="sig-name descname">header_factory</code><a class="headerlink" href="#email.policy.EmailPolicy.header_factory" title="永久链接至目标">¶</a></dt>
<dd><p>A callable that takes two arguments, <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>, where
<code class="docutils literal notranslate"><span class="pre">name</span></code> is a header field name and <code class="docutils literal notranslate"><span class="pre">value</span></code> is an unfolded header field
value, and returns a string subclass that represents that header.  A
default <code class="docutils literal notranslate"><span class="pre">header_factory</span></code> (see <a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>) is provided
that supports custom parsing for the various address and date <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>
header field types, and the major MIME header field stypes.  Support for
additional custom parsing will be added in the future.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.content_manager">
<code class="sig-name descname">content_manager</code><a class="headerlink" href="#email.policy.EmailPolicy.content_manager" title="永久链接至目标">¶</a></dt>
<dd><p>An object with at least two methods: get_content and set_content.  When
the <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> or
<a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> method of an
<a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> object is called, it calls the
corresponding method of this object, passing it the message object as its
first argument, and any arguments or keywords that were passed to it as
additional arguments.  By default <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> is set to
<a class="reference internal" href="email.contentmanager.html#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code class="xref py py-data docutils literal notranslate"><span class="pre">raw_data_manager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<p>The class provides the following concrete implementations of the abstract
methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>:</p>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_max_count">
<code class="sig-name descname">header_max_count</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_max_count" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the value of the
<a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_count</span></code></a> attribute of the
specialized class used to represent the header with the given name.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_source_parse">
<code class="sig-name descname">header_source_parse</code><span class="sig-paren">(</span><em class="sig-param">sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_source_parse" title="永久链接至目标">¶</a></dt>
<dd><p>The name is parsed as everything up to the '<code class="docutils literal notranslate"><span class="pre">:</span></code>' and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_store_parse">
<code class="sig-name descname">header_store_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_store_parse" title="永久链接至目标">¶</a></dt>
<dd><p>The name is returned unchanged.  If the input value has a <code class="docutils literal notranslate"><span class="pre">name</span></code>
attribute and it matches <em>name</em> ignoring case, the value is returned
unchanged.  Otherwise the <em>name</em> and <em>value</em> are passed to
<code class="docutils literal notranslate"><span class="pre">header_factory</span></code>, and the resulting header object is returned as
the value.  In this case a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised if the input value
contains CR or LF characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_fetch_parse">
<code class="sig-name descname">header_fetch_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_fetch_parse" title="永久链接至目标">¶</a></dt>
<dd><p>If the value has a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute, it is returned to unmodified.
Otherwise the <em>name</em>, and the <em>value</em> with any CR or LF characters
removed, are passed to the <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>, and the resulting
header object is returned.  Any surrogateescaped bytes get turned into
the unicode unknown-character glyph.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold" title="永久链接至目标">¶</a></dt>
<dd><p>Header folding is controlled by the <a class="reference internal" href="#email.policy.EmailPolicy.refold_source" title="email.policy.EmailPolicy.refold_source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">refold_source</span></code></a> policy setting.
A value is considered to be a 'source value' if and only if it does not
have a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute (having a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute means it is a
header object of some sort).  If a source value needs to be refolded
according to the policy, it is converted into a header object by
passing the <em>name</em> and the <em>value</em> with any CR and LF characters removed
to the <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>.  Folding of a header object is done by
calling its <code class="docutils literal notranslate"><span class="pre">fold</span></code> method with the current policy.</p>
<p>Source values are split into lines using <a class="reference internal" href="stdtypes.html#str.splitlines" title="str.splitlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">splitlines()</span></code></a>.  If
the value is not to be refolded, the lines are rejoined using the
<code class="docutils literal notranslate"><span class="pre">linesep</span></code> from the policy and returned.  The exception is lines
containing non-ascii binary data.  In that case the value is refolded
regardless of the <code class="docutils literal notranslate"><span class="pre">refold_source</span></code> setting, which causes the binary data
to be CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold_binary">
<code class="sig-name descname">fold_binary</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold_binary" title="永久链接至目标">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.EmailPolicy.fold" title="email.policy.EmailPolicy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a> if <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">7bit</span></code>, except
that the returned value is bytes.</p>
<p>If <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">8bit</span></code>, non-ASCII binary data is
converted back
into bytes.  Headers with binary data are not refolded, regardless of the
<code class="docutils literal notranslate"><span class="pre">refold_header</span></code> setting, since there is no way to know whether the
binary data consists of single byte characters or multibyte characters.</p>
</dd></dl>

</dd></dl>

<p>The following instances of <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> provide defaults suitable for
specific application domains.  Note that in the future the behavior of these
instances (in particular the <code class="docutils literal notranslate"><span class="pre">HTTP</span></code> instance) may be adjusted to conform even
more closely to the RFCs relevant to their domains.</p>
<dl class="data">
<dt id="email.policy.default">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">default</code><a class="headerlink" href="#email.policy.default" title="永久链接至目标">¶</a></dt>
<dd><p>An instance of <code class="docutils literal notranslate"><span class="pre">EmailPolicy</span></code> with all defaults unchanged.  This policy
uses the standard Python <code class="docutils literal notranslate"><span class="pre">\n</span></code> line endings rather than the RFC-correct
<code class="docutils literal notranslate"><span class="pre">\r\n</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTP">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">SMTP</code><a class="headerlink" href="#email.policy.SMTP" title="永久链接至目标">¶</a></dt>
<dd><p>Suitable for serializing messages in conformance with the email RFCs.
Like <code class="docutils literal notranslate"><span class="pre">default</span></code>, but with <code class="docutils literal notranslate"><span class="pre">linesep</span></code> set to <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>, which is RFC
compliant.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTPUTF8">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">SMTPUTF8</code><a class="headerlink" href="#email.policy.SMTPUTF8" title="永久链接至目标">¶</a></dt>
<dd><p>The same as <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> except that <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.
Useful for serializing messages to a message store without using encoded
words in the headers.  Should only be used for SMTP transmission if the
sender or recipient addresses have non-ASCII characters (the
<a class="reference internal" href="smtplib.html#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smtplib.SMTP.send_message()</span></code></a> method handles this automatically).</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.HTTP">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">HTTP</code><a class="headerlink" href="#email.policy.HTTP" title="永久链接至目标">¶</a></dt>
<dd><p>Suitable for serializing headers with for use in HTTP traffic.  Like
<code class="docutils literal notranslate"><span class="pre">SMTP</span></code> except that <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (unlimited).</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.strict">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">strict</code><a class="headerlink" href="#email.policy.strict" title="永久链接至目标">¶</a></dt>
<dd><p>Convenience instance.  The same as <code class="docutils literal notranslate"><span class="pre">default</span></code> except that
<code class="docutils literal notranslate"><span class="pre">raise_on_defect</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.  This allows any policy to be made
strict by writing:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">somepolicy</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">strict</span>
</pre></div>
</div>
</dd></dl>

<p>With all of these <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicies</span></code></a>, the effective API of
the email package is changed from the Python 3.2 API in the following ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>Setting a header on a <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> results in that
header being parsed and a header object created.</p></li>
<li><p>Fetching a header value from a <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> results
in that header being parsed and a header object created and
returned.</p></li>
<li><p>Any header object, or any header that is refolded due to the
policy settings, is folded using an algorithm that fully implements the
RFC folding algorithms, including knowing where encoded words are required
and allowed.</p></li>
</ul>
</div></blockquote>
<p>From the application view, this means that any header obtained through the
<a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> is a header object with extra
attributes, whose string value is the fully decoded unicode value of the
header.  Likewise, a header may be assigned a new value, or a new header
created, using a unicode string, and the policy will take care of converting
the unicode string into the correct RFC encoded form.</p>
<p>The header objects and their attributes are described in
<a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>.</p>
<dl class="class">
<dt id="email.policy.Compat32">
<em class="property">class </em><code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">Compat32</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32" title="永久链接至目标">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> is the backward compatibility policy.  It
replicates the behavior of the email package in Python 3.2.  The
<a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> module also defines an instance of this class,
<a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>, that is used as the default policy.  Thus the default
behavior of the email package is to maintain compatibility with Python 3.2.</p>
<p>The following attributes have values that are different from the
<a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> default:</p>
<dl class="attribute">
<dt id="email.policy.Compat32.mangle_from_">
<code class="sig-name descname">mangle_from_</code><a class="headerlink" href="#email.policy.Compat32.mangle_from_" title="永久链接至目标">¶</a></dt>
<dd><p>The default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

<p>The class provides the following concrete implementations of the
abstract methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>:</p>
<dl class="method">
<dt id="email.policy.Compat32.header_source_parse">
<code class="sig-name descname">header_source_parse</code><span class="sig-paren">(</span><em class="sig-param">sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_source_parse" title="永久链接至目标">¶</a></dt>
<dd><p>The name is parsed as everything up to the '<code class="docutils literal notranslate"><span class="pre">:</span></code>' and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_store_parse">
<code class="sig-name descname">header_store_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_store_parse" title="永久链接至目标">¶</a></dt>
<dd><p>The name and value are returned unmodified.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_fetch_parse">
<code class="sig-name descname">header_fetch_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_fetch_parse" title="永久链接至目标">¶</a></dt>
<dd><p>If the value contains binary data, it is converted into a
<a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> object using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.
Otherwise it is returned unmodified.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.fold" title="永久链接至目标">¶</a></dt>
<dd><p>Headers are folded using the <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> folding
algorithm, which preserves existing line breaks in the value, and wraps
each resulting line to the <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>.  Non-ASCII binary data are
CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold_binary">
<code class="sig-name descname">fold_binary</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.fold_binary" title="永久链接至目标">¶</a></dt>
<dd><p>Headers are folded using the <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> folding
algorithm, which preserves existing line breaks in the value, and wraps
each resulting line to the <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>.  If <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> is
<code class="docutils literal notranslate"><span class="pre">7bit</span></code>, non-ascii binary data is CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code>
charset.  Otherwise the original source header is used, with its existing
line breaks and any (RFC invalid) binary data it may contain.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="email.policy.compat32">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">compat32</code><a class="headerlink" href="#email.policy.compat32" title="永久链接至目标">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>, providing  backward compatibility with the
behavior of the email package in Python 3.2.</p>
</dd></dl>

<p class="rubric">脚注</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Originally added in 3.3 as a <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">provisional feature</span></a>.</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="email.generator.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code>: 生成 MIME 文档</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="email.errors.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code>: 异常和缺陷类</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/master/Doc/library/email.policy.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 异常和缺陷类"
             >下一页</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="email.generator: 生成 MIME 文档"
             >上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.9.1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >互联网数据处理</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 电子邮件与 MIME 处理包</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2021, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 1月 30, 2021.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>